<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dice</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600&family=DM+Sans:wght@400;500&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --felt: #1a2f23;
      --felt-light: #243d2e;
      --ivory: #f5f0e6;
      --ivory-dark: #e8e0d0;
      --gold: #c9a962;
      --gold-dim: #8a7542;
      --shadow: rgba(0, 0, 0, 0.4);
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'DM Sans', sans-serif;
      background: var(--felt);
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: pointer;
    }

    canvas {
      display: block;
    }

    /* Felt texture overlay */
    #canvas-container::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 1;
    }

    /* UI Layer */
    .ui-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }

    /* Result display */
    .result {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .result.visible {
      opacity: 1;
    }

    .result-value {
      font-family: 'Cormorant Garamond', serif;
      font-size: clamp(4rem, 12vw, 8rem);
      font-weight: 300;
      color: var(--ivory);
      line-height: 1;
      letter-spacing: -0.02em;
      text-shadow: 0 4px 20px var(--shadow);
    }

    .result-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.3em;
      color: var(--gold-dim);
      margin-top: 0.5rem;
    }

    /* Dice count selector */
    .dice-selector {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      pointer-events: auto;
    }

    .dice-selector-label {
      font-family: 'Cormorant Garamond', serif;
      font-size: 0.7rem;
      font-weight: 400;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: var(--gold-dim);
      opacity: 0.7;
    }

    .dice-selector-track {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 12px 20px;
      background: linear-gradient(
        135deg,
        rgba(201, 169, 98, 0.03) 0%,
        rgba(201, 169, 98, 0.08) 50%,
        rgba(201, 169, 98, 0.03) 100%
      );
      border: 1px solid rgba(201, 169, 98, 0.15);
      border-radius: 60px;
      position: relative;
      backdrop-filter: blur(8px);
    }

    .dice-selector-track::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: 60px;
      padding: 1px;
      background: linear-gradient(
        135deg,
        rgba(201, 169, 98, 0.3) 0%,
        rgba(201, 169, 98, 0.05) 50%,
        rgba(201, 169, 98, 0.3) 100%
      );
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
    }

    .dice-btn {
      width: 52px;
      height: 52px;
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 0;
      position: relative;
      transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .dice-btn:focus {
      outline: none;
    }

    .dice-btn:focus-visible .dice-face {
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.3),
        0 0 0 2px var(--gold);
    }

    .dice-face {
      width: 100%;
      height: 100%;
      background: linear-gradient(
        145deg,
        rgba(245, 240, 230, 0.12) 0%,
        rgba(245, 240, 230, 0.05) 100%
      );
      border: 1px solid rgba(201, 169, 98, 0.25);
      border-radius: 8px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      padding: 8px;
      gap: 2px;
      position: relative;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow:
        0 2px 8px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .dice-btn:hover {
      transform: translateY(-4px) scale(1.05);
    }

    .dice-btn:hover .dice-face {
      border-color: rgba(201, 169, 98, 0.5);
      background: linear-gradient(
        145deg,
        rgba(245, 240, 230, 0.18) 0%,
        rgba(245, 240, 230, 0.08) 100%
      );
      box-shadow:
        0 8px 24px rgba(0, 0, 0, 0.35),
        0 0 20px rgba(201, 169, 98, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .dice-btn:hover .pip {
      background: var(--gold);
      box-shadow: 0 0 6px rgba(201, 169, 98, 0.5);
    }

    .dice-btn.active {
      transform: translateY(-2px);
    }

    .dice-btn.active .dice-face {
      background: linear-gradient(
        145deg,
        var(--ivory) 0%,
        var(--ivory-dark) 100%
      );
      border-color: var(--gold);
      box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(201, 169, 98, 0.3),
        0 0 60px rgba(201, 169, 98, 0.15),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
    }

    .dice-btn.active .pip {
      background: var(--felt);
      box-shadow: none;
    }

    .pip {
      width: 8px;
      height: 8px;
      background: var(--gold-dim);
      border-radius: 50%;
      opacity: 0;
      transform: scale(0);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      justify-self: center;
      align-self: center;
    }

    .pip.visible {
      opacity: 1;
      transform: scale(1);
    }

    /* Pip positions in 3x3 grid */
    .pip:nth-child(1) { grid-area: 1 / 1; }  /* top-left */
    .pip:nth-child(2) { grid-area: 1 / 2; }  /* top-center */
    .pip:nth-child(3) { grid-area: 1 / 3; }  /* top-right */
    .pip:nth-child(4) { grid-area: 2 / 1; }  /* mid-left */
    .pip:nth-child(5) { grid-area: 2 / 2; }  /* center */
    .pip:nth-child(6) { grid-area: 2 / 3; }  /* mid-right */
    .pip:nth-child(7) { grid-area: 3 / 1; }  /* bottom-left */
    .pip:nth-child(8) { grid-area: 3 / 2; }  /* bottom-center */
    .pip:nth-child(9) { grid-area: 3 / 3; }  /* bottom-right */

    /* Dice face pip patterns */
    [data-count="1"] .pip:nth-child(5) { opacity: 1; transform: scale(1); }

    [data-count="2"] .pip:nth-child(1),
    [data-count="2"] .pip:nth-child(9) { opacity: 1; transform: scale(1); }

    [data-count="3"] .pip:nth-child(1),
    [data-count="3"] .pip:nth-child(5),
    [data-count="3"] .pip:nth-child(9) { opacity: 1; transform: scale(1); }

    [data-count="4"] .pip:nth-child(1),
    [data-count="4"] .pip:nth-child(3),
    [data-count="4"] .pip:nth-child(7),
    [data-count="4"] .pip:nth-child(9) { opacity: 1; transform: scale(1); }

    [data-count="5"] .pip:nth-child(1),
    [data-count="5"] .pip:nth-child(3),
    [data-count="5"] .pip:nth-child(5),
    [data-count="5"] .pip:nth-child(7),
    [data-count="5"] .pip:nth-child(9) { opacity: 1; transform: scale(1); }

    /* Staggered entrance animation */
    .dice-selector-track {
      animation: selectorFadeIn 0.8s ease-out 0.5s both;
    }

    .dice-btn {
      animation: diceEnter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    }

    .dice-btn:nth-child(1) { animation-delay: 0.6s; }
    .dice-btn:nth-child(2) { animation-delay: 0.7s; }
    .dice-btn:nth-child(3) { animation-delay: 0.8s; }
    .dice-btn:nth-child(4) { animation-delay: 0.9s; }
    .dice-btn:nth-child(5) { animation-delay: 1.0s; }

    @keyframes selectorFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes diceEnter {
      from {
        opacity: 0;
        transform: translateY(15px) rotate(-10deg) scale(0.8);
      }
      to {
        opacity: 1;
        transform: translateY(0) rotate(0deg) scale(1);
      }
    }

    /* Selection ripple effect */
    .dice-btn::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 12px;
      background: radial-gradient(circle, rgba(201, 169, 98, 0.4) 0%, transparent 70%);
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.4s ease;
      pointer-events: none;
    }

    .dice-btn.active::after {
      opacity: 1;
      transform: scale(1.2);
      animation: pulseGlow 2s ease-in-out infinite;
    }

    @keyframes pulseGlow {
      0%, 100% {
        opacity: 0.6;
        transform: scale(1.1);
      }
      50% {
        opacity: 0.3;
        transform: scale(1.25);
      }
    }

    /* Hint text */
    .hint {
      position: absolute;
      bottom: 145px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: var(--gold-dim);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.5;
      transition: opacity 0.5s ease;
    }

    .hint.hidden {
      opacity: 0;
    }

    /* Rolling state */
    .rolling .hint {
      opacity: 0;
    }

    /* Vignette */
    .vignette {
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
      pointer-events: none;
    }

    /* Loading */
    .loading {
      position: fixed;
      inset: 0;
      background: var(--felt);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s ease;
    }

    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-text {
      font-family: 'Cormorant Garamond', serif;
      font-size: 1.5rem;
      color: var(--gold-dim);
      letter-spacing: 0.1em;
    }
  </style>
</head>
<body>
  <div class="loading">
    <span class="loading-text">Loading...</span>
  </div>

  <div id="canvas-container"></div>

  <div class="ui-layer">
    <div class="vignette"></div>

    <div class="result">
      <div class="result-value">â€”</div>
      <div class="result-label">Total</div>
    </div>

    <div class="hint">Click anywhere to roll</div>

    <div class="dice-selector">
      <span class="dice-selector-label">Select Dice</span>
      <div class="dice-selector-track">
        <button class="dice-btn active" data-count="1" aria-label="1 die">
          <div class="dice-face">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </button>
        <button class="dice-btn" data-count="2" aria-label="2 dice">
          <div class="dice-face">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </button>
        <button class="dice-btn" data-count="3" aria-label="3 dice">
          <div class="dice-face">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </button>
        <button class="dice-btn" data-count="4" aria-label="4 dice">
          <div class="dice-face">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </button>
        <button class="dice-btn" data-count="5" aria-label="5 dice">
          <div class="dice-face">
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
            <span class="pip"></span><span class="pip"></span><span class="pip"></span>
          </div>
        </button>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

    // ============ CANNON.js Physics (inline minimal version) ============
    // Using a simplified physics approach for dice

    // Physics constants for realistic dice behavior
    const PHYSICS = {
      // Core physics
      gravity: 28,
      restitution: 0.3,
      diceRestitution: 0.35,

      // Light damping - let physics do the work
      linearDamping: 0.995,
      angularDamping: 0.98,

      // Settling thresholds
      settleSpeedThreshold: 0.1,
      settleAngSpeedThreshold: 0.15,
      settleFlatnessThreshold: 0.995,
      settleFramesRequired: 8,

      // Bounce
      minBounceVelocity: 0.4,
      bounceAngularReduction: 0.6,
      groundFriction: 0.4,

      // Collision
      diceCollisionRadius: 0.866,
    };

    class PhysicsDie {
      constructor(position) {
        this.position = new THREE.Vector3(position.x, position.y, position.z);
        this.velocity = new THREE.Vector3();
        this.quaternion = new THREE.Quaternion();
        this.angularVelocity = new THREE.Vector3();
        this.settled = false;
        this.settleCounter = 0;
        this.size = 1;
      }

      applyImpulse(force, torque) {
        this.velocity.add(force);
        this.angularVelocity.add(torque);
        this.settled = false;
        this.settleCounter = 0;
      }

      // Get how flat the die is (1 = perfectly flat, 0 = on corner)
      getFlatness() {
        const upWorld = new THREE.Vector3(0, 1, 0);
        const faceNormals = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, -1, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1),
        ];

        let maxDot = 0;
        for (const normal of faceNormals) {
          const worldNormal = normal.clone().applyQuaternion(this.quaternion);
          const dot = Math.abs(worldNormal.dot(upWorld));
          if (dot > maxDot) maxDot = dot;
        }
        return maxDot;
      }

      // Get detailed ground contact information
      getGroundContactInfo() {
        const halfSize = this.size / 2;
        const groundY = 0;
        const contactThreshold = 0.05;

        const corners = [
          new THREE.Vector3(-halfSize, -halfSize, -halfSize),
          new THREE.Vector3(-halfSize, -halfSize, halfSize),
          new THREE.Vector3(-halfSize, halfSize, -halfSize),
          new THREE.Vector3(-halfSize, halfSize, halfSize),
          new THREE.Vector3(halfSize, -halfSize, -halfSize),
          new THREE.Vector3(halfSize, -halfSize, halfSize),
          new THREE.Vector3(halfSize, halfSize, -halfSize),
          new THREE.Vector3(halfSize, halfSize, halfSize),
        ];

        let contactCount = 0;
        let lowestY = Infinity;
        let lowestCorner = null;

        for (const corner of corners) {
          const worldCorner = corner.clone()
            .applyQuaternion(this.quaternion)
            .add(this.position);

          if (worldCorner.y < lowestY) {
            lowestY = worldCorner.y;
            lowestCorner = worldCorner;
          }

          if (worldCorner.y < groundY + contactThreshold) {
            contactCount++;
          }
        }

        return {
          isOnGround: lowestY <= groundY + 0.01,
          penetration: Math.max(0, groundY - lowestY),
          contactCount,
          lowestCorner,
          isStable: contactCount >= 3
        };
      }

      // Simple damping - let natural physics work
      applyDamping() {
        this.velocity.multiplyScalar(PHYSICS.linearDamping);
        this.angularVelocity.multiplyScalar(PHYSICS.angularDamping);
      }

      // Apply torque to tip dice off edges/corners and settle flat
      applyStabilizingTorque(dt, contactInfo) {
        const upWorld = new THREE.Vector3(0, 1, 0);
        const faceNormals = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, -1, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1),
        ];

        // Find the face most aligned with up
        let bestNormal = null;
        let maxDot = -1;
        for (const normal of faceNormals) {
          const worldNormal = normal.clone().applyQuaternion(this.quaternion);
          const dot = worldNormal.dot(upWorld);
          if (dot > maxDot) {
            maxDot = dot;
            bestNormal = worldNormal;
          }
        }

        // Apply torque to align that face with up
        if (bestNormal && maxDot < 0.999) {
          const torqueAxis = new THREE.Vector3().crossVectors(bestNormal, upWorld);
          const torqueMagnitude = Math.asin(Math.min(1, torqueAxis.length()));

          if (torqueAxis.length() > 0.001) {
            torqueAxis.normalize();
            // Strong torque to tip dice quickly - like gravity would
            // maxDot ~0.57 on corner, ~0.71 on edge, ~1.0 on face
            const tiltAmount = 1 - maxDot; // 0 when flat, ~0.43 on corner
            const stabilizeStrength = 480 + tiltAmount * 960; // 480-1440 range
            this.angularVelocity.add(
              torqueAxis.multiplyScalar(torqueMagnitude * stabilizeStrength * dt)
            );
          }
        }

        // Aggressive damping when nearly flat to settle instantly
        if (maxDot > 0.95) {
          // Very close to flat - slam to stop
          this.velocity.x *= 0.3;
          this.velocity.z *= 0.3;
          this.angularVelocity.multiplyScalar(0.3);
        } else if (maxDot > 0.85) {
          // Getting flat - heavy damping
          this.velocity.x *= 0.5;
          this.velocity.z *= 0.5;
          this.angularVelocity.multiplyScalar(0.5);
        }
      }

      update(dt) {
        if (this.settled) return;

        // Apply gravity
        this.velocity.y -= PHYSICS.gravity * dt;

        // Apply simple damping
        this.applyDamping();

        // Update position
        this.position.add(this.velocity.clone().multiplyScalar(dt));

        // Update rotation using quaternion
        const angVelLength = this.angularVelocity.length();
        if (angVelLength > 0.0001) {
          const axis = this.angularVelocity.clone().normalize();
          const angle = angVelLength * dt;
          const deltaQ = new THREE.Quaternion().setFromAxisAngle(axis, angle);
          this.quaternion.premultiply(deltaQ);
          this.quaternion.normalize();
        }

        // Ground collision (re-check after movement)
        const newContactInfo = this.getGroundContactInfo();

        if (newContactInfo.penetration > 0) {
          // Push up to ground level
          this.position.y += newContactInfo.penetration;

          // Apply bounce if moving down fast enough
          if (this.velocity.y < -PHYSICS.minBounceVelocity) {
            this.velocity.y = -this.velocity.y * PHYSICS.restitution;

            // Apply ground friction to horizontal velocity
            const frictionFactor = 1 - PHYSICS.groundFriction * 0.3;
            this.velocity.x *= frictionFactor;
            this.velocity.z *= frictionFactor;

            // Reduce angular velocity on bounce
            this.angularVelocity.multiplyScalar(PHYSICS.bounceAngularReduction);

            // Reset settle counter on significant bounce
            this.settleCounter = 0;
          } else {
            // Too slow to bounce - stop vertical motion
            this.velocity.y = Math.max(0, this.velocity.y);
          }

          // Apply stabilizing torque when on ground
          this.applyStabilizingTorque(dt, newContactInfo);
        }

        // Wall collisions
        const bounds = 4;
        if (Math.abs(this.position.x) > bounds) {
          this.position.x = Math.sign(this.position.x) * bounds;
          this.velocity.x = -this.velocity.x * PHYSICS.restitution;
          this.settleCounter = 0;
        }
        if (Math.abs(this.position.z) > bounds) {
          this.position.z = Math.sign(this.position.z) * bounds;
          this.velocity.z = -this.velocity.z * PHYSICS.restitution;
          this.settleCounter = 0;
        }

        // Check if settled
        const speed = this.velocity.length();
        const angSpeed = this.angularVelocity.length();
        const flatness = this.getFlatness();

        if (speed < PHYSICS.settleSpeedThreshold &&
            angSpeed < PHYSICS.settleAngSpeedThreshold &&
            flatness > PHYSICS.settleFlatnessThreshold &&
            newContactInfo.isOnGround) {
          this.settleCounter++;
          if (this.settleCounter > PHYSICS.settleFramesRequired) {
            this.settled = true;
            this.snapToFace();
          }
        } else {
          // Gradual decrease instead of immediate reset
          this.settleCounter = Math.max(0, this.settleCounter - 1);
        }
      }

      snapToFace() {
        // Find which face is up and snap perfectly
        const upWorld = new THREE.Vector3(0, 1, 0);
        const faceNormals = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, -1, 0),
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 0, -1),
        ];

        let bestNormal = null;
        let maxDot = -1;
        for (const normal of faceNormals) {
          const worldNormal = normal.clone().applyQuaternion(this.quaternion);
          const dot = worldNormal.dot(upWorld);
          if (dot > maxDot) {
            maxDot = dot;
            bestNormal = normal;
          }
        }

        // Create quaternion that aligns bestNormal with up
        if (bestNormal) {
          const currentUp = bestNormal.clone().applyQuaternion(this.quaternion);
          const rotationAxis = new THREE.Vector3().crossVectors(currentUp, upWorld);
          if (rotationAxis.length() > 0.001) {
            rotationAxis.normalize();
            const angle = Math.acos(Math.min(1, currentUp.dot(upWorld)));
            const correction = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle);
            this.quaternion.premultiply(correction);
            this.quaternion.normalize();
          }
        }

        // Set position to rest flat
        this.position.y = this.size / 2;
        this.velocity.set(0, 0, 0);
        this.angularVelocity.set(0, 0, 0);
      }

      getValue() {
        // Check which face is pointing up (positive Y)
        const faces = [
          { dir: new THREE.Vector3(0, 1, 0), value: 1 },   // Top
          { dir: new THREE.Vector3(0, -1, 0), value: 6 },  // Bottom
          { dir: new THREE.Vector3(1, 0, 0), value: 3 },   // Right
          { dir: new THREE.Vector3(-1, 0, 0), value: 4 },  // Left
          { dir: new THREE.Vector3(0, 0, 1), value: 2 },   // Front
          { dir: new THREE.Vector3(0, 0, -1), value: 5 },  // Back
        ];

        let maxDot = -Infinity;
        let topValue = 1;

        for (const face of faces) {
          const transformed = face.dir.clone().applyQuaternion(this.quaternion);
          const dot = transformed.y;
          if (dot > maxDot) {
            maxDot = dot;
            topValue = face.value;
          }
        }

        return topValue;
      }
    }

    // ============ Dice Collision System ============

    class DiceCollisionSystem {
      constructor(physicsDice) {
        this.dice = physicsDice;
      }

      // Get all 8 corners of a die in world space
      getWorldCorners(die) {
        const halfSize = die.size / 2;
        const corners = [
          new THREE.Vector3(-halfSize, -halfSize, -halfSize),
          new THREE.Vector3(-halfSize, -halfSize, halfSize),
          new THREE.Vector3(-halfSize, halfSize, -halfSize),
          new THREE.Vector3(-halfSize, halfSize, halfSize),
          new THREE.Vector3(halfSize, -halfSize, -halfSize),
          new THREE.Vector3(halfSize, -halfSize, halfSize),
          new THREE.Vector3(halfSize, halfSize, -halfSize),
          new THREE.Vector3(halfSize, halfSize, halfSize),
        ];

        return corners.map(c =>
          c.clone().applyQuaternion(die.quaternion).add(die.position)
        );
      }

      // Check if a point is inside a die's OBB, return penetration info
      getPointPenetration(point, die) {
        const halfSize = die.size / 2;

        // Transform point to die's local space
        const localPoint = point.clone()
          .sub(die.position)
          .applyQuaternion(die.quaternion.clone().invert());

        // Find penetration along each axis
        const penetrations = [
          { depth: halfSize - Math.abs(localPoint.x), normal: new THREE.Vector3(Math.sign(localPoint.x), 0, 0) },
          { depth: halfSize - Math.abs(localPoint.y), normal: new THREE.Vector3(0, Math.sign(localPoint.y), 0) },
          { depth: halfSize - Math.abs(localPoint.z), normal: new THREE.Vector3(0, 0, Math.sign(localPoint.z)) },
        ];

        // If any axis has negative penetration, point is outside
        for (const p of penetrations) {
          if (p.depth < 0) {
            return { depth: 0, normal: null };
          }
        }

        // Find minimum penetration axis (collision normal)
        penetrations.sort((a, b) => a.depth - b.depth);
        const minPen = penetrations[0];

        // Transform normal back to world space
        const worldNormal = minPen.normal.applyQuaternion(die.quaternion);

        return { depth: minPen.depth, normal: worldNormal };
      }

      // Check for OBB collision between two dice
      checkOBBCollision(dieA, dieB) {
        const cornersA = this.getWorldCorners(dieA);
        const cornersB = this.getWorldCorners(dieB);

        let deepestPenetration = 0;
        let collisionNormal = null;
        let contactPoint = null;

        // Check A's corners against B's OBB
        for (const corner of cornersA) {
          const penetration = this.getPointPenetration(corner, dieB);
          if (penetration.depth > deepestPenetration) {
            deepestPenetration = penetration.depth;
            collisionNormal = penetration.normal;
            contactPoint = corner;
          }
        }

        // Check B's corners against A's OBB
        for (const corner of cornersB) {
          const penetration = this.getPointPenetration(corner, dieA);
          if (penetration.depth > deepestPenetration) {
            deepestPenetration = penetration.depth;
            collisionNormal = penetration.normal ? penetration.normal.clone().negate() : null;
            contactPoint = corner;
          }
        }

        if (deepestPenetration > 0 && collisionNormal) {
          return { dieA, dieB, depth: deepestPenetration, normal: collisionNormal, contactPoint };
        }

        return null;
      }

      // Resolve a collision between two dice
      resolveCollision(collision) {
        const { dieA, dieB, depth, normal, contactPoint } = collision;

        // 1. Separate the dice (positional correction)
        const separation = normal.clone().multiplyScalar(depth * 0.5);
        dieA.position.add(separation);
        dieB.position.sub(separation);

        // 2. Calculate relative velocity at contact point
        const rA = contactPoint.clone().sub(dieA.position);
        const rB = contactPoint.clone().sub(dieB.position);

        const velA = dieA.velocity.clone().add(
          new THREE.Vector3().crossVectors(dieA.angularVelocity, rA)
        );
        const velB = dieB.velocity.clone().add(
          new THREE.Vector3().crossVectors(dieB.angularVelocity, rB)
        );

        const relativeVel = velA.clone().sub(velB);
        const normalVel = relativeVel.dot(normal);

        // Only resolve if objects are moving toward each other
        if (normalVel > 0) return;

        // 3. Calculate impulse magnitude (equal mass dice)
        const restitution = PHYSICS.diceRestitution;
        const impulseMagnitude = -(1 + restitution) * normalVel / 2;

        const impulse = normal.clone().multiplyScalar(impulseMagnitude);

        // 4. Apply impulse to linear velocities
        dieA.velocity.add(impulse);
        dieB.velocity.sub(impulse);

        // 5. Apply impulse to angular velocities
        const angularImpulseA = new THREE.Vector3().crossVectors(rA, impulse);
        const angularImpulseB = new THREE.Vector3().crossVectors(rB, impulse);

        dieA.angularVelocity.add(angularImpulseA.multiplyScalar(0.3));
        dieB.angularVelocity.sub(angularImpulseB.multiplyScalar(0.3));

        // 6. Reset settle counters since collision occurred
        dieA.settled = false;
        dieA.settleCounter = 0;
        dieB.settled = false;
        dieB.settleCounter = 0;
      }

      // Detect and resolve all collisions
      detectAndResolve() {
        if (this.dice.length < 2) return;

        for (let i = 0; i < this.dice.length; i++) {
          for (let j = i + 1; j < this.dice.length; j++) {
            const dieA = this.dice[i];
            const dieB = this.dice[j];

            // Skip if both settled
            if (dieA.settled && dieB.settled) continue;

            // Broad phase: sphere-sphere check
            const dist = dieA.position.distanceTo(dieB.position);
            const minDist = PHYSICS.diceCollisionRadius * 2;

            if (dist < minDist) {
              // Narrow phase: OBB collision
              const collision = this.checkOBBCollision(dieA, dieB);
              if (collision) {
                this.resolveCollision(collision);
              }
            }
          }
        }
      }
    }

    // ============ Main App ============

    class DiceApp {
      constructor() {
        this.container = document.getElementById('canvas-container');
        this.dice = [];
        this.physicsDice = [];
        this.diceCount = 1;
        this.isRolling = false;
        this.collisionSystem = null;

        this.init();
        this.createTable();
        this.createDice();
        this.setupEvents();
        this.animate();

        // Hide loading
        setTimeout(() => {
          document.querySelector('.loading').classList.add('hidden');
        }, 500);
      }

      init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a2f23);
        this.scene.fog = new THREE.Fog(0x1a2f23, 8, 20);

        // Camera
        this.camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        this.camera.position.set(0, 8, 8);
        this.camera.lookAt(0, 0, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.container.appendChild(this.renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xfff8e7, 0.4);
        this.scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xfff8e7, 1.5);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 1;
        mainLight.shadow.camera.far = 30;
        mainLight.shadow.camera.left = -10;
        mainLight.shadow.camera.right = 10;
        mainLight.shadow.camera.top = 10;
        mainLight.shadow.camera.bottom = -10;
        mainLight.shadow.bias = -0.001;
        this.scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xc9a962, 0.3);
        fillLight.position.set(-5, 5, -5);
        this.scene.add(fillLight);

        const rimLight = new THREE.PointLight(0xfff8e7, 0.5);
        rimLight.position.set(0, 5, -8);
        this.scene.add(rimLight);
      }

      createTable() {
        // Table surface
        const tableGeometry = new THREE.PlaneGeometry(20, 20);
        const tableMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a2f23,
          roughness: 0.9,
          metalness: 0.0,
        });

        const table = new THREE.Mesh(tableGeometry, tableMaterial);
        table.rotation.x = -Math.PI / 2;
        table.receiveShadow = true;
        this.scene.add(table);

        // Subtle felt pattern
        const patternCanvas = document.createElement('canvas');
        patternCanvas.width = 512;
        patternCanvas.height = 512;
        const ctx = patternCanvas.getContext('2d');
        ctx.fillStyle = '#1a2f23';
        ctx.fillRect(0, 0, 512, 512);

        for (let i = 0; i < 5000; i++) {
          const x = Math.random() * 512;
          const y = Math.random() * 512;
          const brightness = Math.random() * 20 + 26;
          ctx.fillStyle = `rgb(${brightness}, ${brightness + 15}, ${brightness + 5})`;
          ctx.fillRect(x, y, 1, 1);
        }

        const feltTexture = new THREE.CanvasTexture(patternCanvas);
        feltTexture.wrapS = THREE.RepeatWrapping;
        feltTexture.wrapT = THREE.RepeatWrapping;
        feltTexture.repeat.set(4, 4);
        tableMaterial.map = feltTexture;
        tableMaterial.needsUpdate = true;
      }

      createDieMesh() {
        const geometry = new RoundedBoxGeometry(1, 1, 1, 4, 0.08);

        // Create canvas textures for each face
        const materials = [];
        const faceValues = [3, 4, 1, 6, 2, 5]; // Right, Left, Top, Bottom, Front, Back

        for (const value of faceValues) {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');

          // Ivory background
          ctx.fillStyle = '#f5f0e6';
          ctx.fillRect(0, 0, 256, 256);

          // Subtle gradient
          const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 150);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 256, 256);

          // Draw pips
          ctx.fillStyle = '#1a2f23';
          const pipRadius = 18;
          const positions = this.getPipPositions(value);

          for (const pos of positions) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, pipRadius, 0, Math.PI * 2);
            ctx.fill();
          }

          const texture = new THREE.CanvasTexture(canvas);
          texture.anisotropy = 16;

          materials.push(new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.3,
            metalness: 0.0,
          }));
        }

        const die = new THREE.Mesh(geometry, materials);
        die.castShadow = true;
        die.receiveShadow = true;

        return die;
      }

      getPipPositions(value) {
        const c = 128; // center
        const o = 60;  // offset

        const patterns = {
          1: [{ x: c, y: c }],
          2: [{ x: c - o, y: c - o }, { x: c + o, y: c + o }],
          3: [{ x: c - o, y: c - o }, { x: c, y: c }, { x: c + o, y: c + o }],
          4: [{ x: c - o, y: c - o }, { x: c + o, y: c - o }, { x: c - o, y: c + o }, { x: c + o, y: c + o }],
          5: [{ x: c - o, y: c - o }, { x: c + o, y: c - o }, { x: c, y: c }, { x: c - o, y: c + o }, { x: c + o, y: c + o }],
          6: [{ x: c - o, y: c - o }, { x: c - o, y: c }, { x: c - o, y: c + o }, { x: c + o, y: c - o }, { x: c + o, y: c }, { x: c + o, y: c + o }],
        };

        return patterns[value];
      }

      createDice() {
        // Clear existing dice
        for (const die of this.dice) {
          this.scene.remove(die);
        }
        this.dice = [];
        this.physicsDice = [];

        // Create new dice
        for (let i = 0; i < this.diceCount; i++) {
          const die = this.createDieMesh();

          // Position dice in a row
          const spacing = 1.5;
          const totalWidth = (this.diceCount - 1) * spacing;
          const x = -totalWidth / 2 + i * spacing;

          die.position.set(x, 0.5, 0);
          this.scene.add(die);
          this.dice.push(die);

          const physicsDie = new PhysicsDie({ x, y: 0.5, z: 0 });
          physicsDie.settled = true;
          this.physicsDice.push(physicsDie);
        }

        // Initialize collision system
        this.collisionSystem = new DiceCollisionSystem(this.physicsDice);
      }

      roll() {
        if (this.isRolling) return;

        this.isRolling = true;
        document.querySelector('.result').classList.remove('visible');
        document.querySelector('.hint').classList.add('hidden');
        document.body.classList.add('rolling');

        for (let i = 0; i < this.dice.length; i++) {
          const physicsDie = this.physicsDice[i];

          // Reset position above the table - lower drop for faster settling
          const spacing = 1.8; // Increased spacing to prevent immediate overlap
          const totalWidth = (this.diceCount - 1) * spacing;
          const x = -totalWidth / 2 + i * spacing + (Math.random() - 0.5) * 0.3;

          // Lower drop height (4-5 units) for faster settling
          physicsDie.position.set(x, 4 + Math.random() * 1, (Math.random() - 0.5) * 1.5);

          // Random initial rotation - good visual spin
          const randomAxis = new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
          ).normalize();
          physicsDie.quaternion.setFromAxisAngle(randomAxis, Math.random() * Math.PI * 2);

          // More controlled impulse for realistic trajectory
          const force = new THREE.Vector3(
            (Math.random() - 0.5) * 5,  // Reduced horizontal spread
            -3,                          // Reduced downward impulse
            (Math.random() - 0.5) * 5   // Reduced horizontal spread
          );

          // Good tumbling spin
          const torque = new THREE.Vector3(
            (Math.random() - 0.5) * 18,
            (Math.random() - 0.5) * 12,
            (Math.random() - 0.5) * 18
          );

          physicsDie.applyImpulse(force, torque);
        }
      }

      checkSettled() {
        if (!this.isRolling) return;

        const allSettled = this.physicsDice.every(d => d.settled);

        if (allSettled) {
          this.isRolling = false;
          document.body.classList.remove('rolling');

          // Calculate total
          let total = 0;
          for (const physicsDie of this.physicsDice) {
            total += physicsDie.getValue();
          }

          // Show result
          document.querySelector('.result-value').textContent = total;
          document.querySelector('.result').classList.add('visible');
        }
      }

      setupEvents() {
        // Click to roll
        this.container.addEventListener('click', () => this.roll());

        // Spacebar to roll
        window.addEventListener('keydown', (e) => {
          if (e.code === 'Space') {
            e.preventDefault();
            this.roll();
          }
        });

        // Dice count buttons
        document.querySelectorAll('.dice-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();

            document.querySelectorAll('.dice-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            this.diceCount = parseInt(btn.dataset.count);
            this.createDice();

            document.querySelector('.result').classList.remove('visible');
            document.querySelector('.hint').classList.remove('hidden');
          });
        });

        // Resize
        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      animate() {
        requestAnimationFrame(() => this.animate());

        const dt = 1 / 60;

        // Run multiple physics substeps for stability
        const substeps = 2;
        const subDt = dt / substeps;

        for (let step = 0; step < substeps; step++) {
          // Update individual dice physics
          for (let i = 0; i < this.physicsDice.length; i++) {
            this.physicsDice[i].update(subDt);
          }

          // Resolve dice-to-dice collisions
          if (this.collisionSystem && this.physicsDice.length > 1) {
            this.collisionSystem.detectAndResolve();
          }
        }

        // Sync meshes with physics
        for (let i = 0; i < this.physicsDice.length; i++) {
          this.dice[i].position.copy(this.physicsDice[i].position);
          this.dice[i].quaternion.copy(this.physicsDice[i].quaternion);
        }

        this.checkSettled();
        this.renderer.render(this.scene, this.camera);
      }
    }

    // Start app
    new DiceApp();
  </script>
</body>
</html>
